#include <cassert>
#include <iostream>
#include <queue>
#include <stack>
#include <unordered_set>

#include "arithmetic_op.h"
#include "assign.h"
#include "ast.h"
#include "fun_call.h"
#include "function.h"
#include "if_then_else.h"
#include "integer.h"
#include "logic_op.h"
#include "parser.hpp"
#include "print.h"
#include "type.h"
#include "var.h"
#include "while.h"

#include "scanner.h"
#include "parser.hpp"
#include "interpreter.h"

void visit(ASTNode* node, std::stack<std::string>& result_stack,
           std::queue<std::string>& result_queue);

int main() {
    Interpreter i;
    int res = i.parse();
    /*
    auto abs_fun = std::make_unique<Function>();
    abs_fun->name = "abs";
    abs_fun->args = {{"x", Type::INT}};

    {
        auto st = std::make_unique<IfThenElse>();
        st->op.op = "<";
        {
            auto lhs = std::make_unique<Var>();
            lhs->name = "x";
            st->op.lhs = std::move(lhs);
            auto rhs = std::make_unique<Integer>();
            rhs->val = 0;
            st->op.rhs = std::move(rhs);
        }

        {
            auto st2 = std::make_unique<ArithOp>();
            st2->op = "-";
            auto lhs = std::make_unique<Integer>();
            lhs->val = 0;
            st2->lhs = std::move(lhs);
            auto rhs = std::make_unique<Var>();
            rhs->name = "x";
            st2->rhs = std::move(rhs);
            st->return_true.statement = std::move(st2);
        }
        {
            auto var = std::make_unique<Var>();
            var->name = "x";
            st->return_false.statement = std::move(var);
        }
        abs_fun->body.push_back(std::move(st));
    }
    abs_fun->return_type = Type::INT;

    auto sum_fun = std::make_unique<Function>();
    sum_fun->name = "sum";
    sum_fun->args = {{"x", Type::INT}, {"y", Type::INT}};
    sum_fun->return_type = Type::INT;

    {
        auto var = std::make_unique<VarDef>();
        var->name = "z";
        var->type = Type::INT;
        sum_fun->body.push_back(std::move(var));

        auto ass = std::make_unique<Assign>();
        ass->var = "z";
        auto three = std::make_unique<Integer>();
        three->val = 3;
        ass->st = std::move(three);
        sum_fun->body.push_back(std::move(ass));

        auto whil = std::make_unique<While>();
        {
            auto st4 = std::make_unique<LogicOp>();
            st4->op = "<";
            auto lhs = std::make_unique<Var>();
            lhs->name = "z";
            st4->lhs = std::move(lhs);
            auto rhs = std::make_unique<Integer>();
            rhs->val = 20;
            st4->rhs = std::move(rhs);
            whil->condition = std::move(st4);
        }

        auto ass2 = std::make_unique<Assign>();
        ass2->var = "z";

        auto st2 = std::make_unique<ArithOp>();
        st2->op = "+";
        auto lhs = std::make_unique<Var>();
        lhs->name = "z";
        st2->lhs = std::move(lhs);
        {
            auto st3 = std::make_unique<ArithOp>();
            st3->op = "+";
            auto lhs2 = std::make_unique<Var>();
            lhs2->name = "x";
            st3->lhs = std::move(lhs2);
            auto rhs = std::make_unique<Var>();
            rhs->name = "y";
            st3->rhs = std::move(rhs);
            st2->rhs = std::move(st3);
        }
        ass2->st = std::move(st2);

        whil->body.push_back(std::move(ass2));

        sum_fun->body.push_back(std::move(whil));

        auto ret = std::make_unique<Return>();
        auto v = std::make_unique<Var>();
        v->name = "z";
        ret->statement = std::move(v);
        sum_fun->body.push_back(std::move(ret));
    }

    Function main_fun;
    main_fun.name = "main";

    auto abs_fun_call = std::make_unique<FunCall>();
    abs_fun_call->func = abs_fun.get();

    {
        auto st2 = std::make_unique<ArithOp>();
        st2->op = "+";
        auto lhs = std::make_unique<Integer>();
        lhs->val = -10;
        st2->lhs = std::move(lhs);

        auto sum_fun_call = std::make_unique<FunCall>();
        sum_fun_call->func = sum_fun.get();
        {
            auto one = std::make_unique<Integer>();
            one->val = 1;
            auto two = std::make_unique<Integer>();
            two->val = 2;
            sum_fun_call->args.push_back(std::move(one));
            sum_fun_call->args.push_back(std::move(two));
        }
        st2->rhs = std::move(sum_fun_call);
        abs_fun_call->args.push_back(std::move(st2));
    }

    auto print = std::make_unique<Print>();
    print->st = std::move(abs_fun_call);

    main_fun.fun.push_back(std::move(abs_fun));

    main_fun.body.push_back(std::move(print));
    main_fun.return_type = Type::INT;
    */

    std::stack<ASTNode*> st;
    ASTNode* node = root->get();
    std::unordered_set<ASTNode*> set;

    std::stack<std::string> result_stack;
    std::queue<std::string> result_queue;

    while (!st.empty() || node) {
        if (node) {
            st.push(node);
            if (auto f = dynamic_cast<Function*>(node); f) {
                for (auto& s : f->body) {
                    if (!set.count(s.get())) {
                        node = s.get();
                        break;
                    }
                }
            } else if (auto pr = dynamic_cast<Print*>(node); pr) {
                node = pr->st.get();
            } else if (auto fc = dynamic_cast<FunCall*>(node); fc) {
                node = fc->func;
            } else if (auto ifthen = dynamic_cast<IfThenElse*>(node); ifthen) {
                if (!set.count(&ifthen->op))
                    node = &ifthen->op;
                else if (!set.count(&ifthen->return_true))
                    node = &ifthen->return_true;
                else if (!set.count(&ifthen->return_false))
                    node = &ifthen->return_false;
                else
                    node = nullptr;
            } else if (auto logic_op = dynamic_cast<LogicOp*>(node); logic_op) {
                if (!set.count(logic_op->lhs.get()))
                    node = logic_op->lhs.get();
                else if (!set.count(logic_op->rhs.get()))
                    node = logic_op->rhs.get();
                else
                    node = nullptr;
            } else if (auto ret = dynamic_cast<Return*>(node); ret) {
                node = ret->statement.get();
            } else if (auto arith_op = dynamic_cast<ArithOp*>(node); arith_op) {
                if (!set.count(arith_op->lhs.get()))
                    node = arith_op->lhs.get();
                else if (!set.count(arith_op->rhs.get()))
                    node = arith_op->rhs.get();
                else
                    node = nullptr;
            } else if (auto var_def = dynamic_cast<VarDef*>(node); var_def) {
                node = nullptr;
            } else if (auto var = dynamic_cast<Var*>(node); var) {
                node = nullptr;
            } else if (auto integer = dynamic_cast<Integer*>(node); integer) {
                node = nullptr;
            } else if (auto ass = dynamic_cast<Assign*>(node); ass) {
                if (!set.count(ass->st.get()))
                    node = ass->st.get();
                else
                    node = nullptr;
            } else if (auto whil = dynamic_cast<While*>(node); whil) {
                for (auto& s : whil->body) {
                    if (!set.count(s.get())) {
                        node = s.get();
                        break;
                    }
                }
                if (node == whil) {
                    if (!set.count(whil->condition.get())) {
                        node = whil->condition.get();
                    } else {
                        node = nullptr;
                    }
                }
            } else {
                throw std::logic_error("err");
            }
        } else {
            auto* cur = st.top();
            st.pop();
            if (auto f = dynamic_cast<Function*>(cur); f) {
                for (auto& s : f->body) {
                    if (!set.count(s.get())) {
                        st.push(cur);
                        node = s.get();
                        break;
                    }
                }
                if (!node) {
                    visit(cur, result_stack, result_queue);
                    set.insert(cur);
                }
            } else if (auto pr = dynamic_cast<Print*>(cur); pr) {
                visit(cur, result_stack, result_queue);
                set.insert(cur);
            } else if (auto fc = dynamic_cast<FunCall*>(cur); fc) {
                if (!set.count(fc->func)) {
                    st.push(cur);
                    node = fc->func;
                } else {
                    for (auto& s : fc->args) {
                        if (!set.count(s.get())) {
                            st.push(cur);
                            node = s.get();
                            break;
                        }
                    }
                    if (!node) {
                        visit(cur, result_stack, result_queue);
                        set.insert(cur);
                    }
                }
            } else if (auto ifthen = dynamic_cast<IfThenElse*>(cur); ifthen) {
                if (!set.count(&ifthen->return_true)) {
                    st.push(cur);
                    node = &ifthen->return_true;
                } else if (!set.count(&ifthen->return_false)) {
                    st.push(cur);
                    node = &ifthen->return_false;
                } else {
                    visit(cur, result_stack, result_queue);
                    set.insert(cur);
                }
            } else if (auto logic_op = dynamic_cast<LogicOp*>(cur); logic_op) {
                if (!set.count(logic_op->lhs.get())) {
                    st.push(cur);
                    node = logic_op->lhs.get();
                } else if (!set.count(logic_op->rhs.get())) {
                    st.push(cur);
                    node = logic_op->rhs.get();
                } else {
                    visit(cur, result_stack, result_queue);
                    set.insert(cur);
                }
            } else if (auto ret = dynamic_cast<Return*>(cur); ret) {
                visit(cur, result_stack, result_queue);
                set.insert(cur);
            } else if (auto arith_op = dynamic_cast<ArithOp*>(cur); arith_op) {
                if (!set.count(arith_op->lhs.get())) {
                    st.push(cur);
                    node = arith_op->lhs.get();
                } else if (!set.count(arith_op->rhs.get())) {
                    st.push(cur);
                    node = arith_op->rhs.get();
                } else {
                    visit(cur, result_stack, result_queue);
                    set.insert(cur);
                }
            } else if (auto var_def = dynamic_cast<VarDef*>(cur); var_def) {
                visit(cur, result_stack, result_queue);
                set.insert(cur);
            } else if (auto var = dynamic_cast<Var*>(cur); var) {
                visit(cur, result_stack, result_queue);
                set.insert(cur);
            } else if (auto integer = dynamic_cast<Integer*>(cur); integer) {
                visit(cur, result_stack, result_queue);
                set.insert(cur);
            } else if (auto ass = dynamic_cast<Assign*>(cur); ass) {
                visit(cur, result_stack, result_queue);
                set.insert(cur);
            } else if (auto whil = dynamic_cast<While*>(cur); whil) {
                for (auto& s : whil->body) {
                    if (!set.count(s.get())) {
                        node = s.get();
                        break;
                    }
                }
                if (!node) {
                    if (!set.count(whil->condition.get())) {
                        node = whil->condition.get();
                    } else {
                        visit(cur, result_stack, result_queue);
                        set.insert(cur);
                    }
                }
            } else {
                throw std::logic_error("err");
            }
        }
    }

    assert(result_stack.empty());

    std::cout << "#include <iostream>\n\n";

    while (!result_queue.empty()) {
        std::cout << result_queue.front() << "\n\n";
        result_queue.pop();
    }

    return 0;
}

void visit(ASTNode* node, std::stack<std::string>& result_stack,
           std::queue<std::string>& result_queue) {
    if (auto f = dynamic_cast<Function*>(node); f) {
        auto str = to_string(f->return_type) + " " + f->name + "(";
        for (size_t i = 0; i < f->args.size(); ++i) {
            if (i > 0) str += ", ";
            str += to_string(f->args[i].type) + " " + f->args[i].name;
        }
        str += ") {\n";
        assert(result_stack.size() >= f->body.size());
        std::stack<std::string> temp_st;
        for (size_t i = 0; i < f->body.size(); ++i) {
            temp_st.push(result_stack.top());
            result_stack.pop();
        }
        for (size_t i = 0; i < f->body.size(); ++i) {
            if (i > 0) str += "\n";
            str += temp_st.top();
            temp_st.pop();
        }
        str += "\n}";
        result_queue.push(str);
    } else if (auto pr = dynamic_cast<Print*>(node); pr) {
        assert(!result_stack.empty());
        auto a = result_stack.top();
        result_stack.pop();
        result_stack.push("std::cout << (" + a + ");");
    } else if (auto fc = dynamic_cast<FunCall*>(node); fc) {
        assert(result_stack.size() >= fc->args.size());
        std::stack<std::string> temp_st;
        for (size_t i = 0; i < fc->args.size(); ++i) {
            temp_st.push(result_stack.top());
            result_stack.pop();
        }
        auto str = fc->func->name + "(";
        for (size_t i = 0; i < fc->args.size(); ++i) {
            if (i > 0) str += ", ";
            str += temp_st.top();
            temp_st.pop();
        }
        str += ")";
        result_stack.push(str);
    } else if (auto ifthen = dynamic_cast<IfThenElse*>(node); ifthen) {
        assert(result_stack.size() >= 3);
        auto a = result_stack.top();
        result_stack.pop();
        auto b = result_stack.top();
        result_stack.pop();
        auto c = result_stack.top();
        result_stack.pop();
        result_stack.push(std::string("if (") + c + ") { " + b + " } else { " +
                          a + " }");
    } else if (auto logic_op = dynamic_cast<LogicOp*>(node); logic_op) {
        assert(result_stack.size() >= 2);
        auto a = result_stack.top();
        result_stack.pop();
        auto b = result_stack.top();
        result_stack.pop();
        result_stack.push(b + " " + logic_op->op + " " + a);
    } else if (auto ret = dynamic_cast<Return*>(node); ret) {
        assert(!result_stack.empty());
        auto a = result_stack.top();
        result_stack.pop();
        result_stack.push("return " + a + ";");
    } else if (auto arith_op = dynamic_cast<ArithOp*>(node); arith_op) {
        assert(result_stack.size() >= 2);
        auto a = result_stack.top();
        result_stack.pop();
        auto b = result_stack.top();
        result_stack.pop();
        result_stack.push("(" + b + ") " + arith_op->op + " (" + a + ")");
    } else if (auto var_def = dynamic_cast<VarDef*>(node); var_def) {
        result_stack.push(to_string(var_def->type) + " " + var_def->name + ";");
    } else if (auto var = dynamic_cast<Var*>(node); var) {
        result_stack.push(var->name);
    } else if (auto integer = dynamic_cast<Integer*>(node); integer) {
        result_stack.push(std::to_string(integer->val));
    } else if (auto ass = dynamic_cast<Assign*>(node); ass) {
        assert(result_stack.size() >= 1);
        auto a = result_stack.top();
        result_stack.pop();
        result_stack.push(ass->var + " = " + a + ";");
    } else if (auto whil = dynamic_cast<While*>(node); whil) {
        assert(result_stack.size() >= whil->body.size() + 1);
        auto cond = result_stack.top();
        result_stack.pop();
        std::stack<std::string> temp_st;
        for (size_t i = 0; i < whil->body.size(); ++i) {
            temp_st.push(result_stack.top());
            result_stack.pop();
        }
        auto str = "while (" + cond + ") {\n";
        for (size_t i = 0; i < whil->body.size(); ++i) {
            if (i > 0) str += "\n";
            str += temp_st.top();
            temp_st.pop();
        }
        str += "\n}\n";
        result_stack.push(str);
    } else {
        throw std::logic_error("err");
    }
}
